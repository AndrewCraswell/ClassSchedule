@using Ctc.Ods.Types;
@using CTCClassSchedule;
@using CTCClassSchedule.Common;
@using MvcMiniProfiler;
@using System.Text.RegularExpressions;
@using System.Globalization;
@using Microsoft.Security.Application
@using CTCClassSchedule.Models
@model CTCClassSchedule.SearchResultsModel

@{
	MiniProfiler _profiler = MiniProfiler.Current;

	YearQuarter currentQuarter = ViewBag.CurrentYearQuarter;
	// NOTE: we should always have a YearQuarter (searching all quarters is not an option)
	YearQuarter yrq = ViewBag.YearQuarter;	// this is the YRQ being searched

	int itemCount = ViewBag.ItemCount ?? 0;
	int _courseCount = ViewBag.CourseCount ?? 0;
	String classDesc = _courseCount == 1 ? "class" : "classes";
	String sectionDesc = itemCount == 1 ? "section" : "sections";

	IDictionary<string, object> _routeValues = ViewBag.RouteValues;
	_routeValues["YearQuarterID"] = "All";

	string _searchTerm = ViewBag.searchterm;
	ViewBag.PageTitle = yrq.FriendlyName + " class search results for \"" + _searchTerm + "\" at Bellevue College";

}
<div id="scheduleMain" class="page-search">
    @Html.Partial("quarterNavigation", new QuarterNavigationModel { CurrentQuarter = ViewBag.CurrentYearQuarter, NavigationQuarters = ViewBag.QuarterNavMenu, ViewingQuarter = yrq })
    <div id="container" class="sidebar">
        <div id="sidebar">
          @Html.Partial("advancedFacetedSearch", new AdvancedFacetedSearchModel
          {
            IsSearch = true,
            ViewingQuarter = yrq,
            Subjects = Model.Subjects,
            SelectedSubject = ViewBag.Subject
          })
        </div> <!-- #sidebar -->

        <div id="content">

	@if (itemCount == 0)
 {
			<h1 id="pageTitle">No classes were found for &quot;@_searchTerm&quot;</h1>
			<div id="error-noclassesfound">
            <p><strong>TIP:</strong> Try searching for something else, or selecting fewer <em>Refine</em> options to the left.</p>
			</div>
 }
 else
 {
	<div id="searchHeaderInfo">
		<h1 id="searchResultsMsg">
			<strong>&quot;@_searchTerm&quot;</strong> found @itemCount @sectionDesc in @_courseCount @classDesc for @(yrq != null ? yrq.FriendlyName : "ERROR: Unknown quarter")
		</h1>
		<div id="searchPageNum">

		@if (ViewBag.TotalPages > 0)
	{
			<text>page @ViewBag.CurrentPage of @ViewBag.TotalPages</text>
	}
		</div>
	</div>
	using (_profiler.Step("Rendering sections from search results"))
	{
		IEnumerable<SectionWithSeats> linkedSections;
		bool hasLinked;
		int processedCount = 0;

		IList<SectionWithSeats> orderedSections = Model.Section.ToList();

		while (processedCount < orderedSections.Count)
		{
			IEnumerable<SectionWithSeats> remainingSections = orderedSections.Skip(processedCount);

			@*
				TODO: do we have to worry about the first section being IsLinked?
			*@
			SectionWithSeats firstSection = remainingSections.First();

			IEnumerable<SectionWithSeats> sectionBlock = remainingSections.TakeWhile(s =>
															s.CourseID == firstSection.CourseID &&
															s.CourseTitle == firstSection.CourseTitle &&
															s.Credits == firstSection.Credits &&
															s.IsVariableCredits == firstSection.IsVariableCredits);
			processedCount += sectionBlock.Count();

			if (firstSection != null)
			{
				if (!firstSection.IsLinked)
				{
							@*
							TODO: *******************************************************************************
							Is this valid? Can we assume only the first Section's ItemNumber will give us all the linkages?
							*************************************************************************************
							*@
					linkedSections = orderedSections.Where(s => s.IsLinked && s.Yrq.ID == firstSection.Yrq.ID && s.LinkedTo.Trim() == firstSection.ID.ItemNumber);
					hasLinked = linkedSections.Count() > 0;

				<h2 class="classHeading">
			 @if (hasLinked)
		{
				  <span class="combinationClass">Combination class:</span><br />
		}
					<a href="@Url.Action("ClassDetails", "Classes", new { Prefix = Helpers.SubjectWithCommonCourseFlag(firstSection), ClassNum = firstSection.CourseNumber })">
						@Html.SectionCourseHeading(firstSection, searchTerm: _searchTerm)
						@ViewHelpers.DisplayCredits(firstSection)
					</a>
					@if (linkedSections != null && hasLinked)
		 {
			 foreach (SectionWithSeats linkedSec in linkedSections)
			 {
				  <br />
				  <a href="@Url.Action("ClassDetails", "Classes", new { Prefix = Helpers.SubjectWithCommonCourseFlag(linkedSec), ClassNum = linkedSec.CourseNumber })">
					  @Html.SectionCourseHeading(linkedSec, _searchTerm)
					  @ViewHelpers.DisplayCredits(linkedSec)
				  </a>
			 }
		 }
				</h2> @* classHeading *@

				<div class="classInfo">
					<div class="classDetails">
					@*
					*************************************************************************************
					TODO: Is this a bug? Should it be checking .CustomDescription?
					*************************************************************************************
					*@
					@if (!string.IsNullOrWhiteSpace(firstSection.CustomTitle))
		 {
						@Html.Raw(Html.FormatWithSearchTerm(_searchTerm, firstSection.CustomDescription).ToString())
		 }
		 else
		 {
						@Html.Raw(firstSection.CourseDescriptions.Count() == 0 ? string.Empty : Html.FormatWithSearchTerm(_searchTerm, firstSection.CourseDescriptions[0].Description).ToString())
		 }
						<ul>
							<li class="classDetailsLink">
								@Html.ActionLink(String.Concat("View ", Helpers.SubjectWithCommonCourseFlag(firstSection), " ", firstSection.CourseNumber, " details"), "ClassDetails", "Classes", new { Prefix = Helpers.SubjectWithCommonCourseFlag(firstSection), ClassNum = firstSection.CourseNumber }, null)
							</li>
			@foreach (SectionWithSeats linkedSec in linkedSections)
	 {
     string linkedCourseId = Helpers.BuildCourseID(linkedSec.CourseNumber, linkedSec.CourseSubject, linkedSec.IsCommonCourse);
							<li class="classDetailsLink">
								@Html.ActionLink(String.Concat("View ", Helpers.SubjectWithCommonCourseFlag(linkedSec), " ", linkedSec.CourseNumber, " details"), "ClassDetails", "Classes", new { Prefix = Helpers.SubjectWithCommonCourseFlag(linkedSec), ClassNum = linkedSec.CourseNumber }, null)
							</li>
	 }
						</ul>
					</div>
					<p class="classNotes">
						@{
	            IList<string> commonFootnotes = Helpers.ExtractCommonFootnotes(sectionBlock).ToList();
						}
						@ViewHelpers.DisplayFootnotes(commonFootnotes, firstSection.CourseFootnotes)
					</p>
				</div> <!-- classInfo -->

				<ul class='course-block @(yrq.ID.CompareTo(currentQuarter.ID) < 0 ? Html.Raw("course-block-past-quarter") : Html.Raw(string.Empty))'>
					@{
	 foreach (SectionWithSeats sec in sectionBlock)
	 {

		 //bothSections includes a master and its subordinate linked section(s).
		 IEnumerable<SectionWithSeats> multipleSections = new List<SectionWithSeats>() { sec };

		 if (linkedSections != null && hasLinked)
		 {
			 multipleSections = multipleSections.Union(linkedSections).ToList();
		 }

		 // NOTE: We must pass the current ViewData object to RenderPartial here.
		 // If we pass a new ViewDataDictionary it blows away all our ViewBag properties.
     Html.RenderPartial("Sections", new SectionsViewModel
     {
       Sections = multipleSections.ToList(),
       CurrentQuarter = ViewBag.CurrentYearQuarter,
       ViewingQuarter = yrq,
       CommonFootnotes = commonFootnotes,
     });
	 }
					}
				 </ul>
				} @* if (!firstSection.IsLinked) *@

			} @* if (firstSection != null) *@

		} @* while (processedCount < orderedSections.Count) *@
	}
 }



    @if (ViewBag.TotalPages <= 1 && Model.SearchResultNoSection.Count() > 0)
		{
			Html.RenderPartial("NoSectionCourses", Model.SearchResultNoSection);
		}

	@{Html.RenderPartial("Pager");}

    </div> <!-- #content -->
    </div> <!-- #container -->
</div>



@section PageScripts
{
<script type="text/javascript" src="@Url.Content("~/Scripts/CtcClassSchedule.js")"></script>
}
